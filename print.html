<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust on ESP Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="A comprehensive guide on using the Rust programming language with Espressif SoCs and modules">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="overview/index.html"><strong aria-hidden="true">2.</strong> Ecosystem Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overview/using-the-standard-library.html"><strong aria-hidden="true">2.1.</strong> Using the Standard Library (std)</a></li><li class="chapter-item expanded "><a href="overview/bare-metal.html"><strong aria-hidden="true">2.2.</strong> Bare Metal (no_std)</a></li></ol></li><li class="chapter-item expanded "><a href="installation/index.html"><strong aria-hidden="true">3.</strong> Setting Up a Development Environment</a></li><li class="chapter-item expanded "><a href="writing-your-own-application/index.html"><strong aria-hidden="true">4.</strong> Writing Your Own Application</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-your-own-application/generate-project/index.html"><strong aria-hidden="true">4.1.</strong> Generating Projects from Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-your-own-application/generate-project/esp-template.html"><strong aria-hidden="true">4.1.1.</strong> Understanding esp-template</a></li><li class="chapter-item expanded "><a href="writing-your-own-application/generate-project/esp-idf-template.html"><strong aria-hidden="true">4.1.2.</strong> Understanding esp-idf-template</a></li></ol></li><li class="chapter-item expanded "><a href="writing-your-own-application/nostd.html"><strong aria-hidden="true">4.2.</strong> Writing no_std Applications</a></li><li class="chapter-item expanded "><a href="writing-your-own-application/std.html"><strong aria-hidden="true">4.3.</strong> Writing std Applications</a></li></ol></li><li class="chapter-item expanded "><a href="tooling/index.html"><strong aria-hidden="true">5.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tooling/text-editors-and-ides.html"><strong aria-hidden="true">5.1.</strong> Visual Studio Code</a></li><li class="chapter-item expanded "><a href="tooling/espflash.html"><strong aria-hidden="true">5.2.</strong> espflash</a></li><li class="chapter-item expanded "><a href="tooling/debugging/index.html"><strong aria-hidden="true">5.3.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tooling/debugging/probe-rs.html"><strong aria-hidden="true">5.3.1.</strong> probe-rs</a></li><li class="chapter-item expanded "><a href="tooling/debugging/openocd.html"><strong aria-hidden="true">5.3.2.</strong> OpenOCD</a></li><li class="chapter-item expanded "><a href="tooling/debugging/vscode-debugging.html"><strong aria-hidden="true">5.3.3.</strong> Debugging in Visual Studio Code</a></li></ol></li><li class="chapter-item expanded "><a href="tooling/simulating/index.html"><strong aria-hidden="true">5.4.</strong> Simulating</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tooling/simulating/wokwi.html"><strong aria-hidden="true">5.4.1.</strong> Wokwi</a></li><li class="chapter-item expanded "><a href="tooling/simulating/qemu.html"><strong aria-hidden="true">5.4.2.</strong> QEMU</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="misc/troubleshooting.html">Appendix A: Troubleshooting</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust on ESP Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/esp-rs/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The goal of this book is to provide a comprehensive guide on using the <a href="https://www.rust-lang.org/">Rust Programming Language</a> with <a href="https://espressif.com/">Espressif</a> devices.</p>
<p>Rust support for these devices is still a work in progress, and progress is being made rapidly. Because of this, parts of this documentation may be out of date or change dramatically between readings.</p>
<p>For tools and libraries relating to Rust on ESP, please see the <a href="https://github.com/esp-rs/">esp-rs organization</a> on GitHub. This organization is managed by employees of Espressif as well as members of the community.</p>
<blockquote>
<p><strong>A Note on Device Support</strong></p>
<p>The contents of this book apply to the ESP32 series of devices only; this
includes:</p>
<ul>
<li>ESP32 Series</li>
<li>ESP32 C-Series</li>
<li>ESP32 S-Series</li>
<li>ESP32 H-Series</li>
</ul>
<p>The ESP8266 series is outside the scope of this book. Rust support for the
ESP8266 series is limited and is not being officially supported by Espressif.</p>
</blockquote>
<h2 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who This Book is For</a></h2>
<p>This book is intended for people with some experience with Rust, and also assumes rudimentary knowledge of embedded development and electronics. For those without prior experience, we recommend first reading the <a href="introduction.html#assumptions-and-prerequisites">Assumptions and Prerequisites</a> and <a href="introduction.html#other-resources">Other Resources</a> sections to get up to speed.</p>
<h3 id="assumptions-and-prerequisites"><a class="header" href="#assumptions-and-prerequisites">Assumptions and Prerequisites</a></h3>
<ul>
<li>You are comfortable using the Rust Programming Language, and have written and run applications in a desktop environment.</li>
<li>You should be familiar with the idioms of the <a href="https://doc.rust-lang.org/edition-guide/rust-2021/index.html">2021 edition</a>, as this book targets Rust 2021.</li>
<li>You are comfortable developing embedded systems in another language such as C or C++, and are familiar with concepts such as:
<ul>
<li>Cross-compilation</li>
<li>Common digital interfaces like <code>UART</code>, <code>SPI</code>, <code>I²C</code>, etc.</li>
<li>Memory-mapped peripherals</li>
<li>Interrupts</li>
</ul>
</li>
</ul>
<h3 id="other-resources"><a class="header" href="#other-resources">Other Resources</a></h3>
<p>If you are unfamiliar or less experienced with anything mentioned above, or if you would just like more information about a particular topic mentioned in this book, you may find these resources helpful.</p>
<div class="table-wrapper"><table><thead><tr><th>Resource</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a></td><td>If you are not familiar with Rust we recommend reading this book first.</td></tr>
<tr><td><a href="https://docs.rust-embedded.org/book/index.html">The Embedded Rust Book</a></td><td>Here you can find several other resources provided by Rust's Embedded Working Group.</td></tr>
<tr><td><a href="https://docs.rust-embedded.org/embedonomicon/">The Embedonomicon</a></td><td>The nitty-gritty details when doing embedded programming in Rust.</td></tr>
<tr><td><a href="https://esp-rs.github.io/std-training/">Embedded Rust on Espressif</a></td><td>Training material created in cooperation with <a href="https://ferrous-systems.com/">Ferrous Systems</a>.</td></tr>
</tbody></table>
</div>
<h3 id="translations"><a class="header" href="#translations">Translations</a></h3>
<p>This book is currently available in English only. Once the contents of the book stabilize somewhat, we plan on translating the book into additional languages. As translations become available, this section will be updated to include them.</p>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to Use This Book</a></h2>
<p>This book generally assumes that you are reading it front-to-back; content covered in later chapters may not make sense without context from previous chapters.</p>
<h2 id="contributing-to-this-book"><a class="header" href="#contributing-to-this-book">Contributing to This Book</a></h2>
<p>The work on this book is coordinated in <a href="https://github.com/esp-rs/book">this repository</a>.</p>
<p>If you have trouble following the instructions in this book or find that some section of the book is not clear enough or hard to follow, then that's a bug, and it should be reported in <a href="https://github.com/esp-rs/book/issues/">the issue tracker</a> of this book.</p>
<p>Pull requests fixing typos and adding new content are very welcome!</p>
<h2 id="re-using-this-material"><a class="header" href="#re-using-this-material">Re-using This Material</a></h2>
<p>This book is distributed under the following licenses:</p>
<ul>
<li>The code samples and freestanding Cargo projects contained within this book are licensed under the terms of both the <a href="https://opensource.org/licenses/MIT">MIT License</a> and the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License v2.0</a>.</li>
<li>The written prose, pictures, and diagrams contained within this book are licensed under the terms of the Creative Commons <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA v4.0</a> license.</li>
</ul>
<p>TL;DR: If you want to use our text or images in your work, you need to:</p>
<ul>
<li>Give the appropriate credit (i.e. mention this book on your slide, and provide a link to the relevant page)</li>
<li>Provide a link to the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA v4.0</a> licence</li>
<li>Indicate if you have changed the material in any way, and make any changes to our material available under the same licence</li>
</ul>
<p>Please do let us know if you find this book useful!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecosystem-overview"><a class="header" href="#ecosystem-overview">Ecosystem Overview</a></h1>
<p>There are the following approaches to using Rust on Espressif chips:</p>
<ul>
<li>Using the <code>std</code> library, a.k.a. Standard library.</li>
<li>Using the <code>core</code> library (<code>no_std</code>), a.k.a. bare metal development.</li>
</ul>
<p>Both approaches have their advantages and disadvantages, so you should make a decision based on your project's needs. This chapter contains an overview of the two approaches:</p>
<ul>
<li><a href="overview/./using-the-standard-library.html">Using the Standard Library (<code>std</code>)</a></li>
<li><a href="overview/./bare-metal.html">Developing on Bare Metal (<code>no_std</code>)</a></li>
</ul>
<p>See also the comparison of the different runtimes in <a href="https://docs.rust-embedded.org/book/intro/no-std.html#a-no_std-rust-environment">The Embedded Rust Book</a>.</p>
<p>The <a href="https://github.com/esp-rs/">esp-rs organization</a> on GitHub is home to a number of repositories related to running Rust on Espressif chips. Most of the required crates have their source code hosted here.</p>
<blockquote>
<p>A note on the repository naming convention</p>
<p>In the <a href="https://github.com/esp-rs/">esp-rs organization</a> we use the following wording:</p>
<ul>
<li>Repositories starting with <code>esp-idf-</code> are focused on <code>std</code> approach. E.g. <code>esp-idf-hal</code></li>
<li>Repositories starting with <code>esp-</code> are focused on <code>no_std</code> approach. E.g. <code>esp-hal</code></li>
</ul>
<p>It is easy to remember as follows:</p>
<ul>
<li><code>no_std</code> works on top of bare metal, so <code>esp-</code> is an Espressif chip</li>
<li><code>std</code>, apart from bare metal, also needs an <a href="https://github.com/espressif/esp-idf">additional layer</a>, which is <code>esp-idf-</code></li>
</ul>
</blockquote>
<h2 id="support-for-espressif-products"><a class="header" href="#support-for-espressif-products">Support for Espressif Products</a></h2>
<blockquote>
<p><strong>Notes</strong>:</p>
<ul>
<li>✅ - The feature is implemented or supported</li>
<li>⏳ - The feature is under development</li>
<li>❌ - The feature is not supported</li>
</ul>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Chip</th><th style="text-align: center"><code>std</code></th><th style="text-align: center"><code>no_std</code></th></tr></thead><tbody>
<tr><td>ESP32</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-C2</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-C3</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-C6</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-S2</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-S3</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-H2</td><td style="text-align: center">✅</td><td style="text-align: center">⏳</td></tr>
<tr><td>ESP8266</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
</tbody></table>
</div>
<p>The products supported in certain circumstances will be called <em>supported Espressif products</em> throughout the book.</p>
<p>As of now, the Espressif products supported by the esp-idf framework are the ones supported for Rust <code>std</code> development. For details on different versions of esp-idf and support of Espressif chips, see <a href="https://github.com/espressif/esp-idf#esp-idf-release-and-soc-compatibility">this table</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-standard-library-std"><a class="header" href="#using-the-standard-library-std">Using the Standard Library (<code>std</code>)</a></h1>
<p>Espressif provides a C-based development framework called <a href="https://github.com/espressif/esp-idf">esp-idf</a> which has, or will have, support for all Espressif chips starting with the ESP32; note that this framework does <em>not</em> support the ESP8266. See also <a href="overview/index.html#support-for-espressif-products">Support for Espressif Products</a>.</p>
<p><code>esp-idf</code>, in turn, provides a <a href="https://sourceware.org/newlib/">newlib</a> environment with enough functionality to build the Rust standard library (<code>std</code>) on top of it. This is the approach that is being taken to enable <code>std</code> support on ESP devices.</p>
<h2 id="current-support"><a class="header" href="#current-support">Current Support</a></h2>
<p>As of now, the Espressif products supported by the <a href="https://github.com/espressif/esp-idf#esp-idf-release-and-soc-compatibility/">esp-idf framework</a> are the ones supported for Rust <code>std</code> development.</p>
<p>When using <code>std</code>, you have access to a lot of features that exist in <a href="https://github.com/espressif/esp-idf">esp-idf</a>, including threads, mutexes and other synchronization primitives, collections, random number generation, sockets...</p>
<h3 id="relevant-esp-rs-crates"><a class="header" href="#relevant-esp-rs-crates">Relevant <code>esp-rs</code> crates</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Repository</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://github.com/esp-rs/embedded-svc">esp-rs/embedded-svc</a></td><td>Abstraction traits for embedded services (<code>WiFi</code>, <code>Network</code>, <code>Httpd</code>, <code>Logging</code>, etc.)</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-idf-svc">esp-rs/esp-idf-svc</a></td><td>An implementation of <a href="https://github.com/esp-rs/embedded-svc">embedded-svc</a> using <code>esp-idf</code> drivers.</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-idf-hal">esp-rs/esp-idf-hal</a></td><td>An implementation of the <code>embedded-hal</code> and other traits using the <code>esp-idf</code> framework.</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-idf-sys">esp-rs/esp-idf-sys</a></td><td>Rust bindings to the <code>esp-idf</code> development framework. Gives raw (<code>unsafe</code>) access to drivers, Wi-Fi and more.</td></tr>
</tbody></table>
</div>
<p>The aforementioned crates have interdependencies, and this relationship can be seen below.</p>
<pre class="mermaid">graph TD;
    esp-idf-hal --&gt; esp-idf-sys &amp; embedded-svc
    esp-idf-svc --&gt; esp-idf-sys &amp; esp-idf-hal &amp; embedded-svc
</pre>
<h3 id="when-you-might-want-to-use-the-standard-library-std"><a class="header" href="#when-you-might-want-to-use-the-standard-library-std">When you might want to use the Standard Library (<code>std</code>)</a></h3>
<ul>
<li>Rich functionality: If your embedded system requires lots of functionality like support for networking protocols, file I/O, or complex data structures, you will likely want to use hosted-environment approach because std libraries provide a wide range of functionality that can be used to build complex applications relatively quickly and efficiently</li>
<li>Portability: The <code>std</code> crate provides a standardized set of APIs that can be used across different platforms and architectures, making it easier to write code that is portable and reusable.</li>
<li>Rapid development: The <code>std</code> crate provides a rich set of functionality that can be used to build applications quickly and efficiently, without worrying, too much, about low-level details.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-on-bare-metal-no_std"><a class="header" href="#developing-on-bare-metal-no_std">Developing on Bare Metal (<code>no_std</code>)</a></h1>
<p>Using <code>no_std</code> may be more familiar to embedded Rust developers; it does not use <code>std</code> (the Rust <a href="https://doc.rust-lang.org/std/index.html"><code>standard</code></a> library) but instead uses a subset, the <a href="https://doc.rust-lang.org/core/index.html"><code>core</code></a> library. <a href="https://docs.rust-embedded.org/">The Embedded Rust Book</a> has a great <a href="https://docs.rust-embedded.org/book/intro/no-std.html">section</a> on this.</p>
<p>It's important to note that since <code>no_std</code> uses the Rust <code>core</code> library, a subset of the Rust <code>standard</code> library,  a <code>no_std</code> crate can compile in <code>std</code> environment but the opposite is not true. Therefore, when creating crates it's worth keeping in mind if it needs the <code>standard</code> library to function.</p>
<h2 id="current-support-1"><a class="header" href="#current-support-1">Current support</a></h2>
<p>The table below covers the current support for <code>no_std</code> at this moment for different Espressif products.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th style="text-align: center"><a href="https://github.com/esp-rs/esp-hal" title="Hardware abstraction layer">HAL</a></th><th style="text-align: center"><a href="https://github.com/esp-rs/esp-wifi" title="Wi-Fi, BLE and ESP-NOW support">Wi-Fi/BLE/ESP-NOW</a></th><th style="text-align: center"><a href="https://github.com/esp-rs/esp-backtrace" title="Exception and panic handlers">Backtrace</a></th><th style="text-align: center"><a href="https://github.com/esp-rs/esp-storage" title="Embedded-storage traits to access unencrypted flash memory">Storage</a></th></tr></thead><tbody>
<tr><td>ESP32</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-C2</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-C3</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-C6</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-S2</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-S3</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-H2</td><td style="text-align: center">⏳</td><td style="text-align: center">⏳</td><td style="text-align: center">✅</td><td style="text-align: center">⏳</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Note</strong>:</p>
<ul>
<li>✅ in Wi-Fi/BLE/ESP-NOW means that the target supports, at least, one of the listed technologies. For details, see <a href="https://github.com/esp-rs/esp-wifi#current-support">Current support</a> table of the esp-wifi repository.</li>
<li><a href="https://github.com/esp-rs/esp8266-hal" title="ESP8266 Hardware abstraction layer">ESP8266 HAL</a> is in maintenance mode and no further development will be done for this chip.</li>
</ul>
</blockquote>
<h3 id="relevant-esp-rs-crates-1"><a class="header" href="#relevant-esp-rs-crates-1">Relevant <code>esp-rs</code> crates</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Repository</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://github.com/esp-rs/esp-hal" title="Hardware abstraction layer">esp-rs/esp-hal</a></td><td>Hardware abstraction layer</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-pacs" title="Peripheral access crates">esp-rs/esp-pacs</a></td><td>Peripheral access crates</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-wifi" title="Wi-Fi, BLE and ESP-NOW support">esp-rs/esp-wifi</a></td><td>Wi-Fi, BLE and ESP-NOW support</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-alloc" title="Simple heap allocator">esp-rs/esp-alloc</a></td><td>Simple heap allocator</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-println" title="print!, println!">esp-rs/esp-println</a></td><td><code>print!</code>,  <code>println!</code></td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-backtrace" title="Exception and panic handlers">esp-rs/esp-backtrace</a></td><td>Exception and panic handlers</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-storage" title="Embedded-storage traits to access unencrypted flash memory">esp-rs/esp-storage</a></td><td>Embedded-storage traits to access unencrypted flash memory</td></tr>
</tbody></table>
</div>
<h3 id="when-you-might-want-to-use-bare-metal-no_std"><a class="header" href="#when-you-might-want-to-use-bare-metal-no_std">When you might want to use bare metal (<code>no_std</code>)</a></h3>
<ul>
<li>Small memory footprint: If your embedded system has limited resources and needs to have a small memory footprint, you will likely want to use bare-metal because <code>std</code> features add a significant amount of final binary size and compilation time.</li>
<li>Direct hardware control: If your embedded system requires more direct control over the hardware, such as low-level device drivers or access to specialized hardware features you will likely want to use bare-metal because <code>std</code> adds abstractions that can make it harder to interact directly with the hardware.</li>
<li>Real-time constraints or time-critical applications: If your embedded system requires real-time performance or low-latency response times because <code>std</code> can introduce unpredictable delays and overhead that can affect real-time performance.</li>
<li>Custom requirements: bare-metal allows more customization and fine-grained control over the behavior of an application, which can be useful in specialized or non-standard environments.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-a-development-environment"><a class="header" href="#setting-up-a-development-environment">Setting Up a Development Environment</a></h1>
<p>At the moment, Espressif SoCs are based on two different architectures: <code>RISC-V</code> and <code>Xtensa</code>. Both architectures support <code>std</code> and <code>no_std</code> approaches.</p>
<p>To set up the development environment, do the following:</p>
<ol>
<li><a href="installation/index.html#install-rust">Install Rust</a></li>
<li>Install requirements based on your target(s)
<ul>
<li><a href="installation/index.html#risc-v-targets-only"><code>RISC-V</code> targets only</a></li>
<li><a href="installation/index.html#risc-v-and-xtensa-targets"><code>RISC-V</code> and <code>Xtensa</code> targets</a></li>
</ul>
</li>
</ol>
<p>As mentioned in the installation procedures below, for <code>std</code> development also don't forget to install <a href="installation/index.html#std-development-requirements"><code>std</code> Development Requirements</a>.</p>
<p>Please note that you can host the development environment in a <a href="installation/index.html#using-containers">container</a>.</p>
<h2 id="install-rust"><a class="header" href="#install-rust">Install Rust</a></h2>
<p>Make sure you have <a href="https://www.rust-lang.org/">Rust</a> installed. If not, see the instructions on the <a href="https://rustup.rs/">rustup</a> website.</p>
<p>When using Windows, make sure you have installed one of the ABIs listed below. For more details, see the <a href="https://rust-lang.github.io/rustup/installation/windows.html">Windows</a> chapter in The rustup book.</p>
<ul>
<li><strong>MSVC</strong>: Recommended ABI, included in the list of <code>rustup</code> default requirements. Use it for interoperability with the software produced by Visual Studio.</li>
<li><strong>GNU</strong>: ABI used by the GCC toolchain. Install it yourself for interoperability with the software built with the MinGW/MSYS2 toolchain.</li>
</ul>
<blockquote>
<p><strong>Warning</strong>: When using Unix based systems, installing Rust via a system package manager (e.g. <code>brew</code>, <code>apt</code>, <code>dnf</code>, etc.) can result in various issues and incompatibilities, so it's best to use <a href="https://rustup.rs/">rustup</a> instead.</p>
</blockquote>
<p>See also <a href="https://rust-lang.github.io/rustup/installation/other.html">alternative installation methods</a>.</p>
<h2 id="risc-v-targets-only"><a class="header" href="#risc-v-targets-only">RISC-V targets only</a></h2>
<p>To build Rust applications for the Espressif chips based on <code>RISC-V</code> architecture, do the following:</p>
<ol>
<li>
<p>Install the <a href="https://rust-lang.github.io/rustup/concepts/channels.html#working-with-nightly-rust"><code>nightly</code></a> toolchain with the <code>rust-src</code> <a href="https://rust-lang.github.io/rustup/concepts/components.html">component</a>:</p>
<pre><code class="language-bash">rustup toolchain install nightly --component rust-src
</code></pre>
</li>
</ol>
<ol start="2">
<li>Set the target:
<ul>
<li>
<p>For <code>no_std</code> (bare-metal) applications, run:</p>
<pre><code class="language-bash">rustup target add riscv32imc-unknown-none-elf # For ESP32-C2 and ESP32-C3
rustup target add riscv32imac-unknown-none-elf # For ESP32-C6 and ESP32-H2
</code></pre>
<p>This target is currently <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html#tier-2">Tier 2</a>; note the different flavors of <code>riscv32</code> target in Rust covering different <a href="https://en.wikichip.org/wiki/risc-v/standard_extensions"><code>RISC-V</code> extensions</a>.</p>
</li>
<li>
<p>For <code>std</code> applications:</p>
<p>Since this target is currently <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html#tier-3">Tier 3</a>, it does not have pre-built objects distributed through <code>rustup</code> and, unlike the <code>no_std</code> target, <strong>nothing needs to be installed</strong>. Refer to the <a href="https://doc.rust-lang.org/nightly/rustc/platform-support/esp-idf.html">*-esp-idf</a> section of the rustc book for the correct target for your device. </p>
<ul>
<li><code>riscv32imc-esp-espidf</code> for MCUs which do not support atomics, like ESP32-C2 and ESP32-C3</li>
<li><code>riscv32imac-esp-espidf</code> for MCUs which support atomics, like ESP32-C6, ESP32-H2, and ESP32-P4</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li>To build <code>std</code> projects, you also need to install:
<ul>
<li><a href="https://llvm.org/"><code>LLVM</code></a> compiler infrastructure</li>
<li>Other <a href="installation/index.html#std-development-requirements"><code>std</code> development requirements</a></li>
<li>In your project's file <code>.cargo/config.toml</code>, add the unstable Cargo <a href="https://doc.rust-lang.org/cargo/reference/unstable.html">feature</a> <code>-Z build-std</code>. Our <a href="installation/../writing-your-own-application/generate-project/index.html">template projects</a> that are discussed later in this book already include this.</li>
</ul>
</li>
</ol>
<p>Now you should be able to build and run projects on the Espressif's <code>RISC-V</code> chips.</p>
<h2 id="risc-v-and-xtensa-targets"><a class="header" href="#risc-v-and-xtensa-targets">RISC-V and Xtensa targets</a></h2>
<p><a href="https://github.com/esp-rs/espup"><code>espup</code></a> is a tool that simplifies installing and maintaining the components required to develop Rust applications for the <code>Xtensa</code> and <code>RISC-V</code> architectures.</p>
<h3 id="1-install-espup"><a class="header" href="#1-install-espup">1. Install <code>espup</code></a></h3>
<p>To install <code>espup</code>, run:</p>
<pre><code class="language-sh">cargo install espup
</code></pre>
<p>You can also directly download pre-compiled <a href="https://github.com/esp-rs/espup/releases">release binaries</a> or use <a href="https://github.com/cargo-bins/cargo-binstall">cargo-binstall</a>.</p>
<h3 id="2-install-neccesary-toolchains"><a class="header" href="#2-install-neccesary-toolchains">2. Install neccesary toolchains</a></h3>
<p>Install all the necessary tools to develop Rust applications for all supported Espressif targets by running:</p>
<pre><code class="language-sh">espup install
</code></pre>
<blockquote>
<p><strong>Note</strong>: <code>std</code> applications require installing additional software covered in <a href="installation/index.html#std-development-requirements"><code>std</code> Development Requirements</a></p>
</blockquote>
<h3 id="3-set-up-the-environment-variables"><a class="header" href="#3-set-up-the-environment-variables">3. Set up the environment variables</a></h3>
<p><code>espup</code> will create an export file that contains some environment variables required to build projects.</p>
<p>On Windows (<code>%USERPROFILE%\export-esp.ps1</code>)</p>
<ul>
<li>There is <strong>no need</strong> to execute the file for Windows users. It is only created to show the modified environment variables.</li>
</ul>
<p>On Unix based systems (<code>$HOME/export-esp.sh</code>). There are different ways of sourcing the file:</p>
<ul>
<li>
<p>Source this file in every terminal:</p>
<ol>
<li>Source the export file: <code>. $HOME/export-esp.sh</code></li>
</ol>
<p>This approach requires running the command in every new shell.</p>
</li>
<li>
<p>Create an alias for executing the <code>export-esp.sh</code>:</p>
<ol>
<li>Copy and paste the following command to your shell’s profile (<code>.profile</code>, <code>.bashrc</code>, <code>.zprofile</code>, etc.): <code>alias get_esprs='. $HOME/export-esp.sh'</code></li>
<li>Refresh the configuration by restarting the terminal session or by running <code>source [path to profile]</code>, for example, <code>source ~/.bashrc</code>.</li>
</ol>
<p>This approach requires running the alias in every new shell.</p>
</li>
<li>
<p>Add the environment variables to your shell's profile directly:</p>
<ol>
<li>Add the content of <code>$HOME/export-esp.sh</code> to your shell ’s profile: <code>cat $HOME/export-esp.sh &gt;&gt; [path to profile]</code>, for example, <code>cat $HOME/export-esp.sh &gt;&gt; ~/.bashrc</code>.</li>
<li>Refresh the configuration by restarting the terminal session or by running <code>source [path to profile]</code>, for example, <code>source ~/.bashrc</code>.</li>
</ol>
<p>This approach <strong>does not</strong> require any sourcing. The <code>export-esp.sh</code> script will be sourced automatically in every shell.</p>
</li>
</ul>
<h3 id="what-espup-installs"><a class="header" href="#what-espup-installs">What espup Installs</a></h3>
<p>To enable support for Espressif targets, <code>espup</code> installs the following tools:</p>
<ul>
<li>Espressif Rust fork with support for Espressif targets</li>
<li><code>nightly</code> toolchain with support for <code>RISC-V</code> targets</li>
<li><code>LLVM</code> <a href="https://github.com/espressif/llvm-project">fork</a> with support for <code>Xtensa</code> targets</li>
<li><a href="https://github.com/espressif/crosstool-NG/">GCC toolchain</a> that links the final binary</li>
</ul>
<p>The forked compiler can coexist with the standard Rust compiler, allowing both to be installed on your system. The forked compiler is invoked when using any of the available <a href="https://rust-lang.github.io/rustup/overrides.html">overriding methods</a>.</p>
<blockquote>
<p><strong>Note</strong>: We are making efforts to upstream our forks</p>
<ol>
<li>Changes in <code>LLVM</code> fork. Already in progress, see the status in this <a href="https://github.com/espressif/llvm-project/issues/4">tracking issue</a>.</li>
<li>Rust compiler forks. If <code>LLVM</code> changes are accepted, we will proceed with the Rust compiler changes.</li>
</ol>
</blockquote>
<h3 id="other-installation-methods-for-xtensa-targets"><a class="header" href="#other-installation-methods-for-xtensa-targets">Other installation methods for Xtensa targets</a></h3>
<ul>
<li>Using <a href="https://github.com/esp-rs/rust-build#download-installer-in-bash">esp-rs/rust-build</a> installation scripts. This was the recommended way in the past, but now the installation scripts are feature frozen, and all new features will only be included in <code>espup</code>. See the repository README for instructions.</li>
<li>Building the Rust compiler with <code>Xtensa</code> support from source. This process is computationally expensive and can take one or more hours to complete depending on your system. It is not recommended unless there is a major reason to go for this approach. Here is the repository to build it from source: <a href="https://github.com/esp-rs/rust">esp-rs/rust repository</a>.</li>
</ul>
<h2 id="std-development-requirements"><a class="header" href="#std-development-requirements"><code>std</code> Development Requirements</a></h2>
<p>Regardless of the target architecture, make sure you have the following required tools installed to build <a href="installation/../overview/using-the-standard-library.html"><code>std</code></a> applications:</p>
<ul>
<li><a href="https://www.python.org/downloads/"><code>python</code></a>: Required by ESP-IDF</li>
<li><a href="https://git-scm.com/downloads"><code>git</code></a>: Required by ESP-IDF</li>
<li><a href="https://github.com/esp-rs/embuild/tree/master/ldproxy"><code>ldproxy</code></a> binary crate: A tool that forwards linker arguments to the actual linker that is also given as an argument to <code>ldproxy</code>. Install it by running:
<pre><code class="language-sh">cargo install ldproxy
</code></pre>
</li>
</ul>
<p>The std runtime uses <a href="https://github.com/espressif/esp-idf">ESP-IDF</a> (Espressif IoT Development Framework) as hosted environment but, users do not need to install it. ESP-IDF is automatically downloaded and installed by <a href="https://github.com/esp-rs/esp-idf-sys">esp-idf-sys</a>, a crate that all std projects need to use, when building a std application.</p>
<h2 id="using-containers"><a class="header" href="#using-containers">Using Containers</a></h2>
<p>Instead of installing directly on your local system, you can host the development environment inside a container. Espressif provides the <a href="https://hub.docker.com/r/espressif/idf-rust/tags">idf-rust</a> image that supports both <code>RISC-V</code> and <code>Xtensa</code> target architectures and enables both <code>std</code> and <code>no_std</code> development.</p>
<p>You can find numerous tags for <code>linux/arm64</code>, and <code>linux/amd64</code> platforms.</p>
<p>For each Rust release, we generate the tag with the following naming convention:</p>
<ul>
<li><code>&lt;chip&gt;_&lt;rust-toolchain-version&gt;</code>
<ul>
<li>For example, <code>esp32_1.64.0.0</code> contains the ecosystem for developing <code>std</code>, and <code>no_std</code> applications for <code>ESP32</code> with the <code>1.64.0.0</code> Xtensa Rust toolchain.</li>
</ul>
</li>
</ul>
<p>There are special cases</p>
<ul>
<li><code>&lt;chip&gt;</code> can be <code>all</code> which indicates compatibility with all Espressif targets</li>
<li><code>&lt;rust-toolchain-version&gt;</code> can be <code>latest</code> which indicates the latest release of the <code>Xtensa</code> Rust toolchain</li>
</ul>
<p>Depending on your operating system, you can choose any container runtime, such as <a href="https://www.docker.com/">Docker</a>, <a href="https://podman.io/">Podman</a>, or <a href="https://github.com/lima-vm/lima">Lima</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-your-own-application"><a class="header" href="#writing-your-own-application">Writing Your Own Application</a></h1>
<p>With the appropriate Rust compiler and toolchain installed, you're now ready to create an application.</p>
<p>You can write an application in the following ways:</p>
<ul>
<li>Generate from a template: (<strong>Strongly recommended</strong>). Gives you a configured project, saves time and prevents possible errors.</li>
<li>Start from scratch using Cargo: Requires more expertise since you need to configure several parts of the project.
<blockquote>
<p>Note: Starting a project with Cargo does not provide any advantage, only mentioned here since it's the usual way of generating a project in Rust.</p>
</blockquote>
</li>
</ul>
<p>This chapter won't cover the instructions on how to create a project from scratch with <code>cargo</code>, it will only focus on generating a project from template project.</p>
<p>During this chapter, we will use some tools that will be covered in more details in the next chapter, <a href="writing-your-own-application/../tooling/index.html">Tooling</a>, feel free to peek into it when required.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-projects-from-templates"><a class="header" href="#generating-projects-from-templates">Generating Projects from Templates</a></h1>
<p>We currently maintain two template repositories:</p>
<ul>
<li><a href="https://github.com/esp-rs/esp-template">esp-template</a> - <code>no_std</code> template.</li>
<li><a href="https://github.com/esp-rs/esp-idf-template">esp-idf-template</a> - <code>std</code> template.</li>
</ul>
<p>Both templates are based on <a href="https://github.com/cargo-generate/cargo-generate">cargo-generate</a>, a tool that allows you to create a new project based on some existing template. In our case <a href="https://github.com/esp-rs/esp-idf-template">esp-idf-template</a> or <a href="https://github.com/esp-rs/esp-template">esp-template</a> can be used to generate an application with all the required configuration and dependencies.</p>
<ol>
<li>
<p>Install <code>cargo generate</code>:</p>
<pre><code class="language-shell">cargo install cargo-generate
</code></pre>
</li>
<li>
<p>Generate a project based in one of the templates:</p>
<ul>
<li>esp-template:
<pre><code class="language-shell">cargo generate -a esp-rs/esp-template
</code></pre>
See <a href="writing-your-own-application/generate-project/./esp-template.html">Understanding esp-template</a> for more details on the template project.</li>
<li>esp-idf-template:
<pre><code class="language-shell">cargo generate esp-rs/esp-idf-template cargo
</code></pre>
See <a href="writing-your-own-application/generate-project/./esp-idf-template.html">Understanding esp-idf-template</a> for more details on the template project.</li>
</ul>
<p>When the <code>cargo generate</code> subcommand is invoked, you will be prompted to answer a number of questions regarding the target of your application. Upon completion of this process, you will have a buildable project with all the correct configuration.</p>
</li>
<li>
<p>Build/Run the generated project:</p>
<ul>
<li>Using <code>cargo build</code> will compile the project using the appropriate toolchain and target.</li>
<li>Using <code>cargo run</code> will compile the project, flash it, and open a serial monitor with our chip.</li>
</ul>
</li>
</ol>
<h2 id="using-dev-containers-in-the-templates"><a class="header" href="#using-dev-containers-in-the-templates">Using Dev Containers in the templates</a></h2>
<p>Both template repositories have a prompt for Dev Containers support, when using Dev Containers in the templates it will add support for:</p>
<ul>
<li><a href="https://code.visualstudio.com/docs/remote/containers#_quick-start-open-an-existing-folder-in-a-container">VS Code Dev Containers</a></li>
<li><a href="https://docs.github.com/en/codespaces/developing-in-codespaces/creating-a-codespace">GitHub Codespaces</a></li>
</ul>
<p>Dev Containers use the <a href="https://hub.docker.com/r/espressif/idf-rust/tags"><code>idf-rust</code> container image</a>, that was explained in the <a href="writing-your-own-application/generate-project/../../installation/index.html#using-containers">Using Container section</a> of the installation chapter, and provide an environment ready to develop Rust applications for Espressif chips with no installation required. Dev Containers also have integration with <a href="https://wokwi.com/">Wokwi simulator</a>, to simulate the project, and allow flashing from the container using <a href="https://github.com/bjoernQ/esp-web-flash-server">web flash</a>.</p>
<p>For more details on Dev Containers, see <a href="https://github.com/esp-rs/esp-template/tree/main/docs#dev-containers">Dev Container</a> section of the template README.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-esp-template"><a class="header" href="#understanding-esp-template">Understanding esp-template</a></h1>
<p>Now that we know how to <a href="writing-your-own-application/generate-project/./index.html">generate a no_std project</a>, let's inspect what the generated
project contains and try to understand every part of it.</p>
<h2 id="inspecting-the-generated-project"><a class="header" href="#inspecting-the-generated-project">Inspecting the generated Project</a></h2>
<p>When creating a project from <a href="https://github.com/esp-rs/esp-template">esp-template</a> with the following answers:</p>
<ul>
<li>Which MCU to target? · <code>esp32c3</code></li>
<li>Use template default values? · <code>true</code></li>
</ul>
<p>For this explanation we will use the default values, if you want further modifications, see the <a href="https://github.com/esp-rs/esp-template#esp-template">additional prompts</a> when not using default values.</p>
<p>It should generate a file structure like this:</p>
<pre><code class="language-text">├── .cargo
│   └── config.toml
├── src
│   └── main.rs
├── .gitignore
├── Cargo.toml
├── LICENSE-APACHE
├── LICENSE-MIT
└── rust-toolchain.toml
</code></pre>
<p>Before going further, let's see what these files are for.</p>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/config.html">.cargo/config.toml</a>
<ul>
<li>The Cargo configuration</li>
<li>This defines a few options to correctly build the project</li>
<li>Contains <code>runner = &quot;espflash flash --monitor&quot;</code> - this means you can just use <code>cargo run</code> to flash and monitor your code</li>
</ul>
</li>
<li>src/main.rs
<ul>
<li>The main source file of the newly created project</li>
<li>For details, see the <a href="writing-your-own-application/generate-project/esp-template.html#mainrs"><code>main.rs</code></a> section below.</li>
</ul>
</li>
<li><a href="https://git-scm.com/docs/gitignore">.gitignore</a>
<ul>
<li>Tells <code>git</code> which folders and files to ignore</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/manifest.html">Cargo.toml</a>
<ul>
<li>The usual Cargo manifest declaring some meta-data and dependencies of the project</li>
</ul>
</li>
<li>LICENSE-APACHE, LICENSE_MIT
<ul>
<li>Those are the most common licenses used in the Rust ecosystem</li>
<li>If you want to apply a different license, you can delete these files and change the license in <code>Cargo.toml</code></li>
</ul>
</li>
<li><a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">rust-toolchain.toml</a>
<ul>
<li>Defines which Rust toolchain to use
<ul>
<li>The toolchain will be <code>nightly</code> or <code>esp</code> depending on your target.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="mainrs"><a class="header" href="#mainrs"><code>main.rs</code></a></h2>
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

use esp_backtrace as _;
use esp_println::println;
use hal::{clock::ClockControl, peripherals::Peripherals, prelude::*, timer::TimerGroup, Rtc};

#[entry]
fn main() -&gt; ! {
    let peripherals = Peripherals::take();
    let system = peripherals.SYSTEM.split();
    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();

    // Disable the RTC and TIMG watchdog timers
    let mut rtc = Rtc::new(peripherals.RTC_CNTL);
    let timer_group0 = TimerGroup::new(peripherals.TIMG0, &amp;clocks);
    let mut wdt0 = timer_group0.wdt;
    let timer_group1 = TimerGroup::new(peripherals.TIMG1, &amp;clocks);
    let mut wdt1 = timer_group1.wdt;
    rtc.swd.disable();
    rtc.rwdt.disable();
    wdt0.disable();
    wdt1.disable();

    println!(&quot;Hello world!&quot;);

    loop {}
}</code></pre>
<p>That is quite a lot of code. Let's see what it is good for.</p>
<ul>
<li><code>#![no_std]</code>
<ul>
<li>This tells the Rust compiler that this code doesn't use <code>libstd</code></li>
</ul>
</li>
<li><code>#![no_main]</code>
<ul>
<li>The <code>no_main</code> attribute says that this program won't use the standard main interface, which is tailored for command-line applications that receive arguments. Instead of the standard main, we'll use the entry attribute from the <code>riscv-rt</code> crate to define a custom entry point. In this program, we have named the entry point <code>main</code>, but any other name could have been used. The entry point function must be a <a href="https://doc.rust-lang.org/beta/rust-by-example/fn/diverging.html">diverging function</a>. I.e. it has the signature <code>fn foo() -&gt; !</code>; this type indicates that the function never returns – which means that the program never terminates.</li>
</ul>
</li>
<li><code>use esp_backtrace as _;</code>
<ul>
<li>Since we are in a bare-metal environment, we need a panic-handler that runs if a panic occurs in code</li>
<li>There are a few different crates you can use (e.g <code>panic-halt</code>) but <code>esp-backtrace</code> provides an implementation that prints the address of a backtrace - together with <code>espflash</code>/<code>espmonitor</code> these addresses can get decoded into source code locations</li>
</ul>
</li>
<li><code>use esp_println::println;</code>
<ul>
<li>Provides <code>println!</code> implementation</li>
</ul>
</li>
<li><code>use hal:{...}</code>
<ul>
<li>We need to bring in some types we are going to use</li>
<li>These are from <code>esp-hal</code></li>
</ul>
</li>
<li><code>let peripherals = Peripherals::take().unwrap();</code>
<ul>
<li>HAL drivers usually take ownership of peripherals accessed via the PAC</li>
<li>Here we take all the peripherals from the PAC to pass them to the HAL drivers later</li>
</ul>
</li>
<li><code>let system = peripherals.SYSTEM.split();</code>
<ul>
<li>Sometimes a peripheral (here the System peripheral) is coarse-grained and doesn't exactly fit the HAL drivers - so here we split the System peripheral into smaller pieces which get passed to the drivers</li>
</ul>
</li>
<li><code>let clocks = ClockControl::boot_defaults(system.clock_control).freeze();</code>
<ul>
<li>Here we configure the system clocks - in this case, we are fine with the defaults</li>
<li>We freeze the clocks, which means we cannot change them later</li>
<li>Some drivers need a reference to the clocks to know how to calculate rates and durations</li>
</ul>
</li>
<li>The next block of code instantiates some peripherals (namely RTC and the two timer groups) to disable the watchdog, which is armed after boot
<ul>
<li>Without that code, the SoC would reboot after some time</li>
<li>There is another way to prevent the reboot: <a href="https://docs.rs/esp32c3-hal/0.2.0/esp32c3_hal/prelude/trait._embedded_hal_watchdog_Watchdog.html#tymethod.feed">feeding</a> the watchdog</li>
</ul>
</li>
<li><code>println!(&quot;Hello world!&quot;);</code>
<ul>
<li>Prints &quot;Hello Wolrd!&quot;</li>
</ul>
</li>
<li><code>loop {}</code>
<ul>
<li>Since our function is supposed to never return, we just &quot;do nothing&quot; in a loop</li>
</ul>
</li>
</ul>
<h2 id="running-the-code"><a class="header" href="#running-the-code">Running the Code</a></h2>
<p>Building and running the code is as easy as</p>
<pre><code class="language-shell">cargo run
</code></pre>
<p>This builds the code according to the configuration and executes <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a> to flash the code to the board.</p>
<p>Since our <a href="https://doc.rust-lang.org/cargo/reference/config.html#targettriplerunner"><code>runner</code> configuration</a> also passes the <code>--monitor</code> argument to <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a> we can see what the code is printing.</p>
<blockquote>
<p>Make sure that you have <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a> installed, otherwise this step will fail. To install <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a>:
<code>cargo install espflash</code></p>
</blockquote>
<p>You should see something similar to this:</p>
<pre><code class="language-text">[2023-04-17T14:17:08Z INFO ] Serial port: '/dev/ttyACM0'
[2023-04-17T14:17:08Z INFO ] Connecting...
[2023-04-17T14:17:09Z INFO ] Using flash stub
[2023-04-17T14:17:09Z WARN ] Setting baud rate higher than 115,200 can cause issues
Chip type:         esp32c3 (revision v0.3)
Crystal frequency: 40MHz
Flash size:        4MB
Features:          WiFi, BLE
MAC address:       60:55:f9:c0:39:7c
App/part. size:    203,920/4,128,768 bytes, 4.94%
[00:00:00] [========================================]      13/13      0x0
[00:00:00] [========================================]       1/1       0x8000
[00:00:01] [========================================]      64/64      0x10000                                                                                                                    [2023-04-17T14:17:11Z INFO ] Flashing has completed!
Commands:
    CTRL+R    Reset chip
    CTRL+C    Exit

ESP-ROM:esp32c3-api1-20210207
Build:Feb  7 2021
rst:0x15 (USB_UART_CHIP_RESET),boot:0xc (SPI_FAST_FLASH_BOOT)
Saved PC:0x40380816
0x40380816 -
    at ??:??
SPIWP:0xee
mode:DIO, clock div:2
load:0x3fcd5820,len:0x16ec
0x3fcd5820 - _stack_start
    at ??:??
load:0x403cc710,len:0x95c
0x403cc710 -
    at ??:??
load:0x403ce710,len:0x2dc0
0x403ce710 -
    at ??:??
SHA-256 comparison failed:
Calculated: 692c10f3e7d531666ff34d02d3da161b3daa41ea629010d031fe3706fbada122
Expected: 9fafed52ab0387e903bde368d0d6bfffe0dcc3d2f90dca069a4db891108c387c
Attempting to boot anyway...
entry 0x403cc710
0x403cc710 -
    at ??:??
I (43) boot: ESP-IDF v5.0-beta1-764-gdbcf640261 2nd stage bootloader
I (43) boot: compile time 11:30:26
I (43) boot: chip revision: V003
I (46) boot.esp32c3: SPI Speed      : 40MHz
I (51) boot.esp32c3: SPI Mode       : DIO
I (56) boot.esp32c3: SPI Flash Size : 4MB
I (61) boot: Enabling RNG early entropy source...
I (66) boot: Partition Table:
I (70) boot: ## Label            Usage          Type ST Offset   Length
I (77) boot:  0 nvs              WiFi data        01 02 00009000 00006000
I (84) boot:  1 phy_init         RF data          01 01 0000f000 00001000
I (92) boot:  2 factory          factory app      00 00 00010000 003f0000
I (99) boot: End of partition table
I (103) esp_image: segment 0: paddr=00010020 vaddr=3c030020 size=05f74h ( 24436) map
I (117) esp_image: segment 1: paddr=00015f9c vaddr=40380000 size=007f8h (  2040) load
I (121) esp_image: segment 2: paddr=0001679c vaddr=00000000 size=0987ch ( 39036)
I (137) esp_image: segment 3: paddr=00020020 vaddr=42000020 size=21c40h (138304) map
I (168) boot: Loaded app from partition at offset 0x10000
I (168) boot: Disabling RNG early entropy source...
Hello world!
</code></pre>
<p>What you see here are messages from the first and second stage bootloader, and then ... our &quot;Hello World&quot; message!</p>
<p>And that is exactly what the code is doing.</p>
<p>You can reboot with <code>CTRL+R</code> or exit with <code>CTRL+C</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-esp-idf-template"><a class="header" href="#understanding-esp-idf-template">Understanding esp-idf-template</a></h1>
<p>Now that we know how to <a href="writing-your-own-application/generate-project/./index.html">generate a std project</a>, let's inspect what the generated project contains and try to understand every part of it.</p>
<h2 id="inspecting-the-generated-project-1"><a class="header" href="#inspecting-the-generated-project-1">Inspecting the generated Project</a></h2>
<p>When creating a project from <a href="https://github.com/esp-rs/esp-idf-template">esp-idf-template</a> with the following answers:</p>
<ul>
<li>Which MCU to target? · <code>esp32c3</code></li>
<li>Use template default values? · <code>true</code></li>
</ul>
<p>For this explanation we will use the default values, if you want further modifications, see the <a href="https://github.com/esp-rs/esp-idf-template#generate-the-project">additional prompts</a> when not using default values.</p>
<p>It should generate a file structure like this:</p>
<pre><code class="language-text">├── .cargo
│   └── config.toml
└── src
    └── main.rs
├── .gitignore
├── build.rs
├── Cargo.toml
├── rust-toolchain.toml
├── sdkconfig.defaults
</code></pre>
<p>Before going further, let's see what these files are for.</p>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/config.html">.cargo/config.toml</a>
<ul>
<li>The Cargo configuration</li>
<li>Contains our target</li>
<li>Contains <code>runner = &quot;espflash flash --monitor&quot;</code> - this means you can just use <code>cargo run</code> to flash and monitor your code</li>
<li>Contains the linker to use, in our case, <a href="https://github.com/esp-rs/embuild/tree/master/ldproxy"><code>ldproxy</code></a></li>
<li>Contains the unstable <code>build-std</code> cargo feature enabled.</li>
<li>Contains the <code>ESP-IDF-VERSION</code> environment variable that tells <a href="https://github.com/esp-rs/esp-idf-sys"><code>esp-idf-sys</code></a> which ESP-IDF version the project will use.</li>
</ul>
</li>
<li>src/main.rs
<ul>
<li>The main source file of the newly created project</li>
<li>For details, see the <a href="writing-your-own-application/generate-project/esp-idf-template.html#mainrs"><code>main.rs</code></a> section below.</li>
</ul>
</li>
<li><a href="https://git-scm.com/docs/gitignore">.gitignore</a>
<ul>
<li>Tells <code>git</code> which folders and files to ignore</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build.rs</a>
<ul>
<li>Propagates linker arguments for <code>ldproxy</code>.</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/manifest.html">Cargo.toml</a>
<ul>
<li>The usual Cargo manifest declaring some meta-data and dependencies of the project</li>
</ul>
</li>
<li><a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">rust-toolchain.toml</a>
<ul>
<li>Defines which Rust toolchain to use
<ul>
<li>The toolchain will be <code>nightly</code> or <code>esp</code> depending on your target.</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/build-system.html#custom-sdkconfig-defaults">sdkconfig.defaults</a>
<ul>
<li>Contains the overridden values from the ESP-IDF defaults.</li>
</ul>
</li>
</ul>
<h2 id="mainrs-1"><a class="header" href="#mainrs-1"><code>main.rs</code></a></h2>
<pre><code class="language-rust ignore">use esp_idf_sys as _; // If using the `binstart` feature of `esp-idf-sys`, always keep this module imported

fn main() {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_sys::link_patches();
    println!(&quot;Hello, world!&quot;);
}</code></pre>
<p>The first line is an import that defines the esp-idf entry-point when the root crate is a binary crate that defines a main function.</p>
<p>Then, we have a usual main function with a  few lines on it:</p>
<ul>
<li>A call to <code>esp_idf_sys::link_patches</code> function that makes sure that a few patches to the ESP-IDF which are implemented in Rust are linked to the final executable.</li>
<li>We print on our console the famous &quot;Hello World!&quot;.</li>
</ul>
<h2 id="running-the-code-1"><a class="header" href="#running-the-code-1">Running the Code</a></h2>
<p>Building and running the code is as easy as</p>
<pre><code class="language-shell">cargo run
</code></pre>
<p>This builds the code according to the configuration and executes <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a> to flash the code to the board.</p>
<p>Since our <a href="https://doc.rust-lang.org/cargo/reference/config.html#targettriplerunner"><code>runner</code> configuration</a> also passes the <code>--monitor</code> argument to <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a> we can see what the code is printing.</p>
<blockquote>
<p>Make sure that you have <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a> installed, otherwise this step will fail. To install <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a>:
<code>cargo install espflash</code></p>
</blockquote>
<p>You should see something similar to this:</p>
<pre><code class="language-text">[2023-04-18T08:05:09Z INFO ] Connecting...
[2023-04-18T08:05:10Z INFO ] Using flash stub
[2023-04-18T08:05:10Z WARN ] Setting baud rate higher than 115,200 can cause issues
Chip type:         esp32c3 (revision v0.3)
Crystal frequency: 40MHz
Flash size:        4MB
Features:          WiFi, BLE
MAC address:       60:55:f9:c0:39:7c
App/part. size:    478,416/4,128,768 bytes, 11.59%
[00:00:00] [========================================]      13/13      0x0
[00:00:00] [========================================]       1/1       0x8000
[00:00:04] [========================================]     227/227     0x10000                                                                   [2023-04-18T08:05:15Z INFO ] Flashing has completed!
Commands:
    CTRL+R    Reset chip
    CTRL+C    Exit

ESP-ROM:esp32c3-api1-20210207
Build:Feb  7 2021
rst:0x15 (USB_UART_CHIP_RESET),boot:0xc (SPI_FAST_FLASH_BOOT)
Saved PC:0x40380816
0x40380816 - esp_restart_noos
    at /home/sergio/Documents/Espressif/tests/esp-rust-app/.embuild/espressif/esp-idf/release-v4.4/components/esp_system/port/soc/esp32c3/system_internal.c:106
SPIWP:0xee
mode:DIO, clock div:2
load:0x3fcd5820,len:0x16ec
0x3fcd5820 - _bss_end
    at ??:??
load:0x403cc710,len:0x95c
0x403cc710 - _iram_data_start
    at ??:??
load:0x403ce710,len:0x2dc0
0x403ce710 - _iram_data_start
    at ??:??
SHA-256 comparison failed:
Calculated: 692c10f3e7d531666ff34d02d3da161b3daa41ea629010d031fe3706fbada122
Expected: 9fafed52ab0387e903bde368d0d6bfffe0dcc3d2f90dca069a4db891108c387c
Attempting to boot anyway...
entry 0x403cc710
0x403cc710 - _iram_data_start
    at ??:??
I (43) boot: ESP-IDF v5.0-beta1-764-gdbcf640261 2nd stage bootloader
I (43) boot: compile time 11:30:26
I (43) boot: chip revision: V003
I (46) boot.esp32c3: SPI Speed      : 40MHz
I (51) boot.esp32c3: SPI Mode       : DIO
I (56) boot.esp32c3: SPI Flash Size : 4MB
I (61) boot: Enabling RNG early entropy source...
I (66) boot: Partition Table:
I (70) boot: ## Label            Usage          Type ST Offset   Length
I (77) boot:  0 nvs              WiFi data        01 02 00009000 00006000
I (84) boot:  1 phy_init         RF data          01 01 0000f000 00001000
I (92) boot:  2 factory          factory app      00 00 00010000 003f0000
I (99) boot: End of partition table
I (103) esp_image: segment 0: paddr=00010020 vaddr=3c050020 size=23b88h (146312) map
I (144) esp_image: segment 1: paddr=00033bb0 vaddr=3fc8a000 size=00cd8h (  3288) load
I (145) esp_image: segment 2: paddr=00034890 vaddr=40380000 size=09ea0h ( 40608) load
I (160) esp_image: segment 3: paddr=0003e738 vaddr=00000000 size=018e0h (  6368)
I (161) esp_image: segment 4: paddr=00040020 vaddr=42000020 size=44c88h (281736) map
I (231) boot: Loaded app from partition at offset 0x10000
I (231) boot: Disabling RNG early entropy source...
I (242) cpu_start: Pro cpu up.
I (251) cpu_start: Pro cpu start user code
I (251) cpu_start: cpu freq: 160000000
I (251) cpu_start: Application information:
I (254) cpu_start: Project name:     libespidf
I (259) cpu_start: App version:      1
I (264) cpu_start: Compile time:     Apr 18 2023 10:04:01
I (270) cpu_start: ELF file SHA256:  0000000000000000...
I (276) cpu_start: ESP-IDF:          424ddb3-dirty
I (281) cpu_start: Min chip rev:     v0.3
I (286) cpu_start: Max chip rev:     v0.99
I (291) cpu_start: Chip rev:         v0.3
I (295) heap_init: Initializing. RAM available for dynamic allocation:
I (303) heap_init: At 3FC8BC00 len 00050B10 (322 KiB): DRAM
I (309) heap_init: At 3FCDC710 len 00002950 (10 KiB): STACK/DRAM
I (315) heap_init: At 50000020 len 00001FE0 (7 KiB): RTCRAM
I (323) spi_flash: detected chip: generic
I (327) spi_flash: flash io: dio
I (331) sleep: Configure to isolate all GPIO pins in sleep state
I (337) sleep: Enable automatic switching of GPIO sleep configuration
I (344) cpu_start: Starting scheduler.
Hello, world!
</code></pre>
<p>As you can see, there are messages from the first and second stage bootloader and then, our &quot;Hello, world!&quot; is printed.</p>
<p>You can reboot with <code>CTRL+R</code> or exit with <code>CTRL+C</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-no_std-applications"><a class="header" href="#writing-no_std-applications">Writing no_std applications</a></h1>
<p>If you want to learn how to develop <code>no_std</code> application, there is training developed for this:</p>
<ul>
<li><a href="https://esp-rs.github.io/no_std-training/">Book of training</a></li>
<li><a href="https://github.com/esp-rs/no_std-training">Repository of the training</a></li>
</ul>
<p>The training is based on <a href="https://github.com/esp-rs/esp-rust-board">ESP32-C3-DevKit-RUST-1</a>. You can use any other Espressif development board but code changes and configuration changes might be needed.</p>
<p>The training contains:</p>
<ul>
<li>Introductory level examples:
<ul>
<li>A basic hello-world (<a href="https://github.com/esp-rs/no_std-training/tree/main/intro/hello-world">Source</a>)</li>
<li>A panic example (<a href="https://github.com/esp-rs/no_std-training/tree/main/intro/panic">Source</a>)</li>
<li>A blinky example (<a href="https://github.com/esp-rs/no_std-training/tree/main/intro/blinky">Source</a>)</li>
<li>A button example (<a href="https://github.com/esp-rs/no_std-training/tree/main/intro/button">Source</a>)</li>
<li>A button with interrupt example (<a href="https://github.com/esp-rs/no_std-training/tree/main/intro/button-interrupt">Source</a>)</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note that there are several examples covering the use of specific peripherals under the examples' folder of every SoC <a href="https://github.com/esp-rs/esp-hal"><code>esp-hal</code></a>. E.g. <a href="https://github.com/esp-rs/esp-hal/tree/main/esp32c3-hal/examples"><code>esp32c3-hal/examples</code></a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-std-applications"><a class="header" href="#writing-std-applications">Writing std applications</a></h1>
<p>If you want to learn how to develop <code>std</code> application, there is a training developed
alongside <a href="https://ferrous-systems.com/">Ferrous Systems</a>:</p>
<ul>
<li><a href="https://esp-rs.github.io/std-training/">Book of training</a></li>
<li><a href="https://github.com/esp-rs/std-training">Repository of the training</a></li>
</ul>
<p>The training is based on <a href="https://github.com/esp-rs/esp-rust-board">ESP32-C3-DevKit-RUST-1</a>. You can use any other Espressif development board, but code changes and configuration changes might be needed.</p>
<p>The training is split into two parts:</p>
<ul>
<li><a href="https://github.com/esp-rs/std-training/tree/main/intro">Introductory level examples</a>:
<ul>
<li>A basic hardware-check (<a href="https://github.com/esp-rs/std-training/tree/main/intro/hardware-check">Source</a>)</li>
<li>An HTTP Client (<a href="https://github.com/esp-rs/std-training/tree/main/intro/http-client">Source</a>)</li>
<li>An HTTP Server (<a href="https://github.com/esp-rs/std-training/tree/main/intro/http-server">Source</a>)</li>
<li>An MQTT Client (<a href="https://github.com/esp-rs/std-training/tree/main/intro/mqtt">Source</a>)</li>
</ul>
</li>
<li><a href="https://github.com/esp-rs/std-training/tree/main/advanced">Advanced level examples</a>:
<ul>
<li>Low-level GPIO</li>
<li>Interrupts in General</li>
<li>I2C Driver (<a href="https://github.com/esp-rs/std-training/tree/main/advanced/i2c-driver">Source</a>)</li>
<li>I2C Sensor Reading (<a href="https://github.com/esp-rs/std-training/tree/main/advanced/i2c-sensor-reading">Source</a>)</li>
<li>GPIO/Button Interrupts (<a href="https://github.com/esp-rs/std-training/tree/main/advanced/button-interrupt">Source</a>)</li>
<li>Driving an RGB LED</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note that there are several examples covering the use of specific peripherals under the examples' folder of  <a href="https://github.com/esp-rs/esp-idf-hal"><code>esp-idf-hal</code></a>. I.e. <a href="https://github.com/esp-rs/esp-idf-hal/tree/master/examples"><code>esp-idf-hal/examples</code></a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tooling"><a class="header" href="#tooling">Tooling</a></h1>
<p>Now that we have our required dependencies installed, and we know how to generate a
template project, we will cover, in more detail, some of the tools that will make
developing Rust applications for ESP targets a lot easier.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h1>
<p>One of the more common development environments is Microsoft's <a href="https://code.visualstudio.com/">Visual Studio Code</a> text editor along with the <a href="https://rust-analyzer.github.io/">Rust Analyzer</a> extension.</p>
<p>Visual Studio Code is an open-source and cross-platform graphical text editor with a rich ecosystem of extensions. The <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">Rust Analyzer extension</a> provides an implementation of the <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> for Rust and additionally includes features like autocompletion, go-to definition, and more.</p>
<p>Visual Studio Code can be installed via most popular package managers, and installers are available on the official website. The <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">Rust Analyzer extension</a> can be installed in Visual Studio Code via the built-in extension manager.</p>
<p>Alongside Rust Analyzer (RA), there are other extensions that might be very helpful:</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml">Even Better TOML</a> for editing TOML-based configuration files</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=serayuzgur.crates">crates</a> to help manage Rust dependencies</li>
</ul>
<h2 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and Tricks</a></h2>
<p>If you are developing for a target that does not have <code>std</code> support, Rust Analyzer can behave strangely, often reporting various errors. This can be resolved by creating a <code>.vscode/settings.json</code> file in your project and populating it with the following:</p>
<pre><code class="language-json">{
  &quot;rust-analyzer.checkOnSave.allTargets&quot;: false
}
</code></pre>
<p>If you are using a custom toolchain, as you would with Xtensa targets, you can provide some hints to <code>cargo</code> via the <code>rust-toolchain.toml</code> file to improve the user experience:</p>
<pre><code class="language-toml">[toolchain]
channel = &quot;esp&quot;
components = [&quot;rustfmt&quot;, &quot;rustc-dev&quot;]
targets = [&quot;xtensa-esp32-none-elf&quot;]
</code></pre>
<h2 id="other-ides"><a class="header" href="#other-ides">Other IDEs</a></h2>
<p>There are other IDEs like <a href="https://www.jetbrains.com/clion/">CLion</a> or <a href="https://www.vim.org/">vim</a> that also have pretty good support for Rust,
but we won't be covering them here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="espflash"><a class="header" href="#espflash">espflash</a></h1>
<p><code>espflash</code> provides a serial flasher utility for Espressif SoCs and modules based on <a href="https://github.com/espressif/esptool">esptool.py</a>.</p>
<p>The <a href="https://github.com/esp-rs/espflash">esp-rs/espflash</a> repository contains two crates, <code>cargo-espflash</code> and <code>espflash</code>. You can find more information on both of these in their respective sections below and in their corresponding README.</p>
<blockquote>
<h4 id="a-note-on-espflash-and-cargo-espflash"><a class="header" href="#a-note-on-espflash-and-cargo-espflash">A note on <code>espflash</code> and <code>cargo-espflash</code>.</a></h4>
<p>The <code>espflash</code> and <code>cargo-espflash</code> commands shown below, assume that version <code>2.0</code> or greater.</p>
</blockquote>
<h2 id="cargo-espflash"><a class="header" href="#cargo-espflash">cargo-espflash</a></h2>
<p>Provides a subcommand for <code>cargo</code> that handles cross-compilation and flashing.</p>
<p>To install:</p>
<pre><code class="language-bash">cargo install cargo-espflash
</code></pre>
<p>This command must be run within a Cargo project, ie. a directory containing a <code>Cargo.toml</code> file. For example, to build an example named 'blinky', flash the resulting binary to a device, and then subsequently start a serial monitor:</p>
<pre><code class="language-bash">cargo espflash flash --example=blinky --monitor
</code></pre>
<p>For more information, please see the <a href="https://github.com/esp-rs/espflash/blob/master/cargo-espflash/README.md">cargo-espflash README</a>.</p>
<h2 id="espflash-1"><a class="header" href="#espflash-1">espflash</a></h2>
<p>Provides a standalone command-line application that flashes an ELF file to a device.</p>
<p>To install:</p>
<pre><code class="language-bash">cargo install espflash
</code></pre>
<p>Assuming you have built an ELF binary by other means already, <code>espflash</code> can be used to download it to your device and monitor the serial port. For example, if you have built the <code>getting-started/blinky</code> example from <a href="https://github.com/espressif/esp-idf">esp-idf</a> using <code>idf.py</code> you might run something like:</p>
<pre><code class="language-bash">espflash flash build/blinky --monitor
</code></pre>
<p>For more information, please see the <a href="https://github.com/esp-rs/espflash/blob/master/espflash/README.md">espflash README</a>.</p>
<p><code>espflash</code> can be used as a Cargo runner by adding the following to your project's <code>.cargo/config.toml</code> file:</p>
<pre><code class="language-toml">[target.'cfg(any(target_arch = &quot;riscv32&quot;, target_arch = &quot;xtensa&quot;))']
runner = &quot;espflash flash --monitor&quot;
</code></pre>
<p>With this configuration, you can flash and monitor your application using <code>cargo run</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>Debugging Rust applications is also possible using different tools that will be covered in this chapter.</p>
<p>Refer to the table below to see which chip is supported in every debugging method:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center"><strong>probe-rs</strong></th><th style="text-align: center"><strong>openODC</strong></th><th style="text-align: center"><strong>VS Code</strong></th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>ESP32</strong></td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-C2</strong></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-C3</strong></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-C6</strong></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-H2</strong></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-S2</strong></td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-S3</strong></td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="probe-rs"><a class="header" href="#probe-rs">probe-rs</a></h1>
<p>The <a href="https://probe.rs/">probe-rs</a> project is a set of tools to interact with embedded MCU's using various debug probes. It is similar to <a href="https://openocd.org/">openOCD</a>, <a href="https://pyocd.io/">PyOCD</a>, <a href="https://www.segger.com/">Segger tools</a>, etc. There is support for <code>ARM</code> &amp; <code>RISC-V</code> architectures along with a collection of tools, including but not limited to:</p>
<ul>
<li>Debugger
<ul>
<li>GDB support.</li>
<li>CLI for interactive debugging.</li>
<li>VSCode extension.</li>
</ul>
</li>
<li>RTT (Real Time Transfer)
<ul>
<li>Similar to app_trace component of IDF.</li>
</ul>
</li>
<li>Flashing algorithms</li>
</ul>
<p>More info about probe-rs &amp; how to set up a project can be found on the <a href="https://probe.rs/">probe-rs</a> website.</p>
<h2 id="usb-jtag-serial-peripheral-for-esp32-c3"><a class="header" href="#usb-jtag-serial-peripheral-for-esp32-c3"><code>USB-JTAG-SERIAL</code> peripheral for ESP32-C3</a></h2>
<p>Starting from <code>probe-rs</code> v0.12, it is possible to flash and debug the ESP32-C3 with the built-in <code>USB-JTAG-SERIAL</code> peripheral, no need for any external hardware debugger. More info on configuring the interface can be found in the <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/api-guides/jtag-debugging/configure-builtin-jtag.html">official documentation</a>.</p>
<h2 id="support-for-espressif-chips"><a class="header" href="#support-for-espressif-chips">Support for Espressif chips</a></h2>
<p><code>probe-rs</code> currently only supports <code>ARM</code> &amp; <code>RISC-V</code>, therefore this limits the number of Espressif chips that can be used at the moment.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Chip</th><th style="text-align: center">Flashing</th><th style="text-align: center">Debugging</th></tr></thead><tbody>
<tr><td style="text-align: center">ESP32-C3</td><td style="text-align: center">✅</td><td style="text-align: center">⚠️</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: <em>Items marked with ⚠️ are currently work in progress, usable but expect bugs.</em></p>
<h2 id="permissions---linux"><a class="header" href="#permissions---linux">Permissions - Linux</a></h2>
<p>On Linux, you may run into permission issues trying to interact with Espressif probes. Installing the following <code>udev</code> rules and reloading should fix that issue.</p>
<pre><code class="language-udev"># Espressif dev kit FTDI
ATTRS{idVendor}==&quot;0403&quot;, ATTRS{idProduct}==&quot;6010&quot;, MODE=&quot;660&quot;, GROUP=&quot;plugdev&quot;, TAG+=&quot;uaccess&quot;

# Espressif USB JTAG/serial debug unit
ATTRS{idVendor}==&quot;303a&quot;, ATTRS{idProduct}==&quot;1001&quot;, MODE=&quot;660&quot;, GROUP=&quot;plugdev&quot;, TAG+=&quot;uaccess&quot;

# Espressif USB Bridge
ATTRS{idVendor}==&quot;303a&quot;, ATTRS{idProduct}==&quot;1002&quot;, MODE=&quot;660&quot;, GROUP=&quot;plugdev&quot;, TAG+=&quot;uaccess&quot;
</code></pre>
<!-- TODO: when probe-rs can actually debug at least a C3 with decent back traces etc, add a section here with an example config: see https://github.com/probe-rs/probe-rs/issues/877 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="openocd"><a class="header" href="#openocd">OpenOCD</a></h1>
<p>Similar to <a href="tooling/debugging/./probe-rs.html">probe-rs</a>, OpenOCD does not have support for the Xtensa architecture. However, Espressif does maintain a fork of OpenOCD under <a href="https://github.com/espressif/openocd-esp32">espressif/openocd-esp32</a> which has support for Espressif's chips.</p>
<p>Instructions on how to install <code>openocd-esp32</code> for your platform can be found in <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/api-guides/jtag-debugging/index.html#setup-of-openocd">the Espressif documentation</a>.</p>
<h2 id="setup-for-espressif-chips"><a class="header" href="#setup-for-espressif-chips">Setup for Espressif chips</a></h2>
<!-- how to choose interface & chip -->
<p>Once installed, it's as simple as running <code>openocd</code> with the correct scripts. For chips with the built-in USB JTAG, there is normally a config that will work out of the box, for example on the ESP32-C3:</p>
<pre><code class="language-ignore">openocd -f board/esp32c3-builtin.cfg
</code></pre>
<p>For other configurations it may require specifying the chip and the interface separately, for example, ESP32 with a J-Link:</p>
<pre><code class="language-ignore">openocd -f interface/jlink.cfg -f target/esp32.cfg
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-in-visual-studio-code"><a class="header" href="#debugging-in-visual-studio-code">Debugging in Visual Studio Code</a></h1>
<p>There is also a possibility to debug with graphical output directly in Visual Studio Code.</p>
<h2 id="esp32"><a class="header" href="#esp32">ESP32</a></h2>
<h3 id="hardware-setup"><a class="header" href="#hardware-setup">Hardware Setup</a></h3>
<p>ESP32 doesn't have a built-in JTAG interface, so you have to connect an external JTAG adapter to the ESP32 board, for example, <a href="https://docs.espressif.com/projects/espressif-esp-iot-solution/en/latest/hw-reference/ESP-Prog_guide.html">ESP-Prog</a> can be used.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">ESP32 Pin</th><th style="text-align: center">JTAG Signal</th></tr></thead><tbody>
<tr><td style="text-align: center">MTDO/GPIO15</td><td style="text-align: center">TDO</td></tr>
<tr><td style="text-align: center">MTDI/GPIO12</td><td style="text-align: center">TDI</td></tr>
<tr><td style="text-align: center">MTCK/GPIO13</td><td style="text-align: center">TCK</td></tr>
<tr><td style="text-align: center">MTMS/GPIO14</td><td style="text-align: center">TMS</td></tr>
<tr><td style="text-align: center">3V3</td><td style="text-align: center">VJTAG</td></tr>
<tr><td style="text-align: center">GND</td><td style="text-align: center">GND</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: On Windows <code>USB Serial Converter A 0403 6010 00</code> driver should be WinUSB.</p>
<h2 id="set-up-vscode"><a class="header" href="#set-up-vscode">Set up VSCode</a></h2>
<ol>
<li>Install <a href="https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug">Cortex-Debug</a> extension for VScode.</li>
<li>Create the <code>.vscode/launch.json</code> file in the project tree you want to debug. <a href="https://github.com/esp-rs/esp32-hal/blob/master/.vscode/launch.json">This</a> can be used as a template file.</li>
<li>Update <strong>executable</strong>, <strong>svdFile</strong>, <strong>serverpath</strong> paths, and <strong>toolchainPrefix</strong> field.</li>
</ol>
<pre><code class="language-jsonc">{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
    {
      // more info at: https://github.com/Marus/cortex-debug/blob/master/package.json
      &quot;name&quot;: &quot;Attach&quot;,
      &quot;type&quot;: &quot;cortex-debug&quot;,
      &quot;request&quot;: &quot;attach&quot;, // attach instead of launch, because otherwise flash write is attempted, but fails
      &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
      &quot;executable&quot;: &quot;target/xtensa-esp32-none-elf/debug/.....&quot;,
      &quot;servertype&quot;: &quot;openocd&quot;,
      &quot;interface&quot;: &quot;jtag&quot;,
      &quot;svdFile&quot;: &quot;../../esp-pacs/esp32/svd/esp32.svd&quot;,
      &quot;toolchainPrefix&quot;: &quot;xtensa-esp32-elf&quot;,
      &quot;openOCDPreConfigLaunchCommands&quot;: [&quot;set ESP_RTOS none&quot;],
      &quot;serverpath&quot;: &quot;C:/Espressif/tools/openocd-esp32/v0.11.0-esp32-20220411/openocd-esp32/bin/openocd.exe&quot;,
      &quot;configFiles&quot;: [&quot;board/esp32-wrover-kit-3.3v.cfg&quot;],
      &quot;overrideAttachCommands&quot;: [
        &quot;set remote hardware-watchpoint-limit 2&quot;,
        &quot;mon halt&quot;,
        &quot;flushregs&quot;
      ],
      &quot;overrideRestartCommands&quot;: [&quot;mon reset halt&quot;, &quot;flushregs&quot;, &quot;c&quot;]
    }
  ]
}
</code></pre>
<h2 id="esp32-c3"><a class="header" href="#esp32-c3">ESP32-C3</a></h2>
<p>Older versions with <strong>revision &lt; 3</strong> <strong>don't</strong> have built-in JTAG interface.</p>
<p>ESP32-C3 with <strong>revision 3</strong> <strong>does</strong> have a built-in JTAG interface, and you don't have to connect an external device to be able to debug. To get the chip revision, run the <code>cargo espflash board-info</code> command.</p>
<h3 id="hardware-setup-1"><a class="header" href="#hardware-setup-1">Hardware Setup</a></h3>
<p>If your ESP32-C3's revision is lesser than 3, follow these instructions, if you have revision 3 you can jump to the <a href="tooling/debugging/vscode-debugging.html#set-up-vscode-1"><strong>Set up VSCode</strong></a> step.</p>
<p>ESP32-C3 <strong>revision 1</strong> and <strong>revision 2</strong> don't have a built-in JTAG interface, so you have to connect an external JTAG adapter to the ESP32-C3 board, for example, <a href="https://docs.espressif.com/projects/espressif-esp-iot-solution/en/latest/hw-reference/ESP-Prog_guide.html">ESP-Prog</a> can be used.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">ESP32-C3 Pin</th><th style="text-align: center">JTAG Signal</th></tr></thead><tbody>
<tr><td style="text-align: center">MTDO/GPIO7</td><td style="text-align: center">TDO</td></tr>
<tr><td style="text-align: center">MTDI/GPIO5</td><td style="text-align: center">TDI</td></tr>
<tr><td style="text-align: center">MTCK/GPIO6</td><td style="text-align: center">TCK</td></tr>
<tr><td style="text-align: center">MTMS/GPIO4</td><td style="text-align: center">TMS</td></tr>
<tr><td style="text-align: center">3V3</td><td style="text-align: center">VJTAG</td></tr>
<tr><td style="text-align: center">GND</td><td style="text-align: center">GND</td></tr>
</tbody></table>
</div>
<p><strong>Note</strong>: On Windows <code>USB Serial Converter A 0403 6010 00</code> driver should be WinUSB.</p>
<h3 id="set-up-vscode-1"><a class="header" href="#set-up-vscode-1">Set up VSCode</a></h3>
<ol>
<li>Install <a href="https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug">Cortex-Debug</a> extension for VScode.</li>
<li>Create the <code>.vscode/launch.json</code> file in the project tree you want to debug. <a href="https://github.com/esp-rs/esp32-hal/blob/master/.vscode/launch.json">This</a> can be used as a template file.</li>
<li>Update <strong>executable</strong>, <strong>svdFile</strong>, <strong>serverpath</strong> paths, and <strong>toolchainPrefix</strong> field.</li>
</ol>
<pre><code class="language-jsonc">{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
    {
      // more info at: https://github.com/Marus/cortex-debug/blob/master/package.json
      &quot;name&quot;: &quot;Attach&quot;,
      &quot;type&quot;: &quot;cortex-debug&quot;,
      &quot;request&quot;: &quot;attach&quot;, // attach instead of launch, because otherwise flash write is attempted, but fails
      &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
      &quot;executable&quot;: &quot;target/riscv32imc-unknown-none-elf/debug/examples/usb_serial_jtag&quot;, //
      &quot;servertype&quot;: &quot;openocd&quot;,
      &quot;interface&quot;: &quot;jtag&quot;,
      &quot;svdFile&quot;: &quot;../../esp-pacs/esp32c3/svd/esp32c3.svd&quot;,
      &quot;toolchainPrefix&quot;: &quot;riscv32-esp-elf&quot;,
      &quot;openOCDPreConfigLaunchCommands&quot;: [&quot;set ESP_RTOS none&quot;],
      &quot;serverpath&quot;: &quot;C:/Espressif/tools/openocd-esp32/v0.11.0-esp32-20220411/openocd-esp32/bin/openocd.exe&quot;,
      &quot;configFiles&quot;: [&quot;board/esp32c3-builtin.cfg&quot;],
      &quot;overrideAttachCommands&quot;: [
        &quot;set remote hardware-watchpoint-limit 2&quot;,
        &quot;mon halt&quot;,
        &quot;flushregs&quot;
      ],
      &quot;overrideRestartCommands&quot;: [&quot;mon reset halt&quot;, &quot;flushregs&quot;, &quot;c&quot;]
    }
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simulating"><a class="header" href="#simulating">Simulating</a></h1>
<p>Simulating projects can be very handy. It allows users to test projects using CI, try projects without having hardware available, and many other scenarios.</p>
<p>At the moment, there are a few ways of simulating Rust projects on Espressif chips, all of them have some limitations, but it's quickly evolving and getting better every day.</p>
<p>In this chapter, we will discuss the different ways of simulation that are available.</p>
<p>Refer to the table below to see which chip is supported in every simulating method:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center"><strong><a href="https://docs.wokwi.com/guides/esp32#simulation-features">Wokwi</a></strong></th><th style="text-align: center"><strong>QEMU</strong></th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>ESP32</strong></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-C2</strong></td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td style="text-align: center"><strong>ESP32-C3</strong></td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td style="text-align: center"><strong>ESP32-C6</strong></td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td style="text-align: center"><strong>ESP32-H2</strong></td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td style="text-align: center"><strong>ESP32-S2</strong></td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td style="text-align: center"><strong>ESP32-S3</strong></td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="wokwi"><a class="header" href="#wokwi">Wokwi</a></h1>
<p><a href="https://wokwi.com/">Wokwi</a> is an online simulator that supports simulating Rust projects (both <code>std</code> and <code>no_std</code>) in ESP Chips,
see <a href="https://wokwi.com/rust">wokwi.com/rust</a> for a list of examples and a way to start new projects.</p>
<p>Wokwi offers Wi-Fi simulation, Virtual Logic Analyzer, and <a href="https://docs.wokwi.com/gdb-debugging">GDB debugging</a> among many other features, see
<a href="https://docs.wokwi.com/">Wokwi documentation</a> for more details. For ESP chips, there is a <a href="https://docs.wokwi.com/guides/esp32#simulation-features">table of simulation features that are currently supported</a>.</p>
<h2 id="using-wokwi-for-vs-code-extension"><a class="header" href="#using-wokwi-for-vs-code-extension">Using Wokwi for VS Code extension</a></h2>
<p>Wokwi offers a VS Code extension that allows users to simulate their project directly from your code editor by only adding a few files. For more information, see <a href="https://docs.wokwi.com/vscode/getting-started">Wokwi documentation</a>.
You can also debug your code using the VS Code debugger, see <a href="https://docs.wokwi.com/vscode/debugging">Debugging your code</a>.</p>
<p>When using any of the <a href="tooling/simulating/./../../writing-your-own-application/generate-project/index.html">templates</a> and not using the default values, there is a prompt (<code>Configure project to support Wokwi simulation with Wokwi VS Code extension?</code>) that generates the required files to use Wokwi VS Code extension.</p>
<p><img src="tooling/simulating/../../assets/wokwi-vscode.png" alt="Wokwi VS Code example" /></p>
<h2 id="using-wokwi-server"><a class="header" href="#using-wokwi-server">Using wokwi-server</a></h2>
<p><a href="https://github.com/MabezDev/wokwi-server">wokwi-server</a> is a CLI tool for launching a Wokwi simulation of your project. I.e., it allows you
to build a project on your machine, or in a container, and simulate the resulting binary.</p>
<p><a href="https://github.com/MabezDev/wokwi-server">wokwi-server</a> also allows simulating your resulting binary on other Wokwi projects, with more hardware parts other than the chip itself. See the <a href="https://github.com/MabezDev/wokwi-server#simulating-your-binary-on-a-custom-wokwi-project">corresponding section of the wokwi-server README</a> for detailed instructions.</p>
<h2 id="custom-chips"><a class="header" href="#custom-chips">Custom chips</a></h2>
<p>Wokwi allows generating custom chips that let you program the behavior of a component not supported in Wokwi. For more details, see the official <a href="https://docs.wokwi.com/chips-api/getting-started">Wokwi documentation</a>.</p>
<p>Custom chips can also be written in Rust!  See <a href="https://github.com/wokwi/wokwi_chip_ll">Wokwi Custom Chip API</a> for more information. E.g:  custom <a href="https://github.com/wokwi/rust_chip_inverter">inverter chip</a> written in Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qemu"><a class="header" href="#qemu">QEMU</a></h1>
<p>Espressif maintains a fork of QEMU in <a href="https://github.com/espressif/qemu">espressif/QEMU</a> with the necessary patches to make it work on Espressif chips.
See the <a href="https://github.com/espressif/qemu/wiki">QEMU wiki</a> for instructions on how to build QEMU and emulate projects with it.</p>
<p>Once you have built QEMU, you should have <code>qemu-system-xtensa</code>.</p>
<h2 id="running-our-project-using-qemu"><a class="header" href="#running-our-project-using-qemu">Running our project using QEMU</a></h2>
<blockquote>
<p><em>NOTE</em>: Only ESP32 is currently supported, so make sure you are compiling for <code>xtensa-esp32-espidf</code> target.</p>
</blockquote>
<p>For running our project in QEMU, we need a firmware/image with bootloader and partition table merged in it.
We can use <a href="https://github.com/esp-rs/espflash/tree/main/cargo-espflash"><code>cargo-espflash</code></a> to generate it:</p>
<pre><code class="language-bash">cargo espflash save-image --chip esp32 --merge &lt;OUTFILE&gt; --release
</code></pre>
<blockquote>
<p>If you prefer to use <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a>, you can achieve the same result by building the project first and then generating image:</p>
<pre><code class="language-bash">cargo build --release
espflash save-image --merge ESP32 target/xtensa-esp32-espidf/release/&lt;NAME&gt; &lt;OUTFILE&gt;
</code></pre>
</blockquote>
<p>Now, run the image in QEMU:</p>
<pre><code class="language-sh">/path/to/qemu-system-xtensa -nographic -machine esp32 -drive file=&lt;OUTFILE&gt;,if=mtd,format=raw
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>Here, we will present a list of common errors that may appear when building a project alongside the reason and a solution to them.</p>
<h2 id="environment-variable-libclang_path-not-set"><a class="header" href="#environment-variable-libclang_path-not-set">Environment variable LIBCLANG_PATH not set</a></h2>
<pre><code class="language-text">thread 'main' panicked at 'Unable to find libclang: &quot;couldn't find any valid shared libraries matching: ['libclang.so', 'libclang-*.so', 'libclang.so.*', 'libclang-*.so.*'], set the `LIBCLANG_PATH` environment variable to a path where one of these files can be found (invalid: [])&quot;', /home/esp/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.60.1/src/lib.rs:2172:31
</code></pre>
<p>We need <code>libclang</code> for <a href="https://github.com/rust-lang/rust-bindgen"><code>bindgen</code></a> to generate the Rust bindings to the ESP-IDF C headers.
Make sure you have sourced the export file generated by <code>espup</code>, see <a href="misc/./../installation/index.html#3-set-up-the-environment-variables">Set up the environment variables</a>.</p>
<h2 id="missing-ldproxy"><a class="header" href="#missing-ldproxy">Missing <code>ldproxy</code></a></h2>
<pre><code class="language-sh">error: linker `ldproxy` not found
  |
  = note: No such file or directory (os error 2)
</code></pre>
<p>If you are trying to build a <code>std</code> application <a href="https://github.com/esp-rs/embuild/tree/master/ldproxy"><code>ldproxy</code></a> must be installed. See <a href="misc/./../installation/index.html#std-development-requirements"><code>std</code> Development Requirements</a></p>
<pre><code class="language-sh">cargo install ldproxy
</code></pre>
<h2 id="using-a-wrong-rust-toolchain"><a class="header" href="#using-a-wrong-rust-toolchain">Using a wrong Rust toolchain</a></h2>
<pre><code class="language-text">$ cargo build
error: failed to run `rustc` to learn about target-specific information

Caused by:
  process didn't exit successfully: `rustc - --crate-name ___ --print=file-names --target xtensa-esp32-espidf --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=cfg` (exit status: 1)
  --- stderr
  error: Error loading target specification: Could not find specification for target &quot;xtensa-esp32-espidf&quot;. Run `rustc --print target-list` for a list of built-in targets
</code></pre>
<p>If you are encountering the previous error or a similar one, you are probably not using the proper Rust toolchain, remember that for Xtensa targets, you need to use Espressif Rust fork toolchain, there are several ways to do it:</p>
<ul>
<li>A <a href="https://rust-lang.github.io/rustup/overrides.html#toolchain-override-shorthand">toolchain override</a> shorthand used on the command-line: <code>cargo +esp</code>.</li>
<li>Set <code>RUSTUP_TOOLCHAIN</code> environment variable to <code>esp</code>.</li>
<li>Set a <a href="https://rust-lang.github.io/rustup/overrides.html#directory-overrides">directory override</a>: <code>rustup override set esp</code></li>
<li>Add a <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">rust-toolchain.toml</a> file to you project:
<pre><code class="language-toml">[toolchain]
channel = &quot;esp&quot;
</code></pre>
</li>
<li>Set <code>esp</code> as <a href="https://rust-lang.github.io/rustup/overrides.html#default-toolchain">default toolchain</a>.</li>
</ul>
<p>For more information on toolchain overriding, see the <a href="https://rust-lang.github.io/rustup/overrides.html#overrides">Overrides chapter of The rustup book</a>.</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<h3 id="long-path-names"><a class="header" href="#long-path-names">Long path names</a></h3>
<p>When using Windows, you may encounter issues building a new project if using long path names. Follow these steps to substitute the path of your project:</p>
<pre><code class="language-powershell">subst r: &lt;pathToYourProject&gt;
cd r:\
</code></pre>
<h3 id="missing-abi"><a class="header" href="#missing-abi">Missing ABI</a></h3>
<pre><code class="language-powershell">  Compiling cc v1.0.69
error: linker `link.exe` not found
  |
  = note: The system cannot find the file specified. (os error 2)

note: the msvc targets depend on the msvc linker but `link.exe` was not found

note: please ensure that VS 2013, VS 2015, VS 2017 or VS 2019 was installed with the Visual C++ option

error: could not compile `compiler_builtins` due to previous error
warning: build failed, waiting for other jobs to finish...
error: build failed
</code></pre>
<p>The reason for this error is that we are missing the MSVC C++, hence we are not meeting the <a href="https://github.com/rust-lang/cc-rs#compile-time-requirements">Compile-time Requirements</a>, please install <a href="https://rust-lang.github.io/rustup/installation/windows.html">Visual Studio 2013 (or later) or the Visual C++ Build Tools 2019</a>. For Visual Studio, make sure to check the &quot;C++ tools&quot; and &quot;Windows 10 SDK&quot; options.
If using GNU ABI, install <a href="https://www.msys2.org/">MinGW/MSYS2 toolchain</a>.</p>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h3 id="i-updated-my-sdkconfigdefaults-file-but-it-doesnt-appear-to-have-had-any-effect"><a class="header" href="#i-updated-my-sdkconfigdefaults-file-but-it-doesnt-appear-to-have-had-any-effect">I updated my <code>sdkconfig.defaults</code> file but it doesn't appear to have had any effect</a></h3>
<p>You must clean your project and rebuild for changes in the <code>sdkconfig.defaults</code> to take effect:</p>
<pre><code class="language-shell ignore">cargo clean
cargo build
</code></pre>
<h3 id="the-documentation-for-the-crates-mentioned-on-this-page-is-out-of-date-or-missing"><a class="header" href="#the-documentation-for-the-crates-mentioned-on-this-page-is-out-of-date-or-missing">The documentation for the crates mentioned on this page is out of date or missing</a></h3>
<p>Due to the <a href="https://docs.rs/about/builds#hitting-resource-limits">resource limits</a> imposed by <a href="https://docs.rs">docs.rs</a>, internet access is blocked while building documentation and as such we are unable to build the documentation for <code>esp-idf-sys</code> or any crate depending on it.</p>
<p>Instead, we are building the documentation and hosting it ourselves on GitHub Pages:</p>
<ul>
<li><a href="https://esp-rs.github.io/esp-idf-hal/esp_idf_hal/"><code>esp-idf-hal</code> Documentation</a></li>
<li><a href="https://esp-rs.github.io/esp-idf-svc/esp_idf_svc/"><code>esp-idf-svc</code> Documentation</a></li>
<li><a href="https://esp-rs.github.io/esp-idf-sys/esp_idf_sys/"><code>esp-idf-sys</code> Documentation</a></li>
</ul>
<h3 id="error-a-stack-overflow-in-task-main-has-been-detected"><a class="header" href="#error-a-stack-overflow-in-task-main-has-been-detected">***ERROR*** A stack overflow in task main has been detected.</a></h3>
<p>If the second-stage bootloader reports this error, you likely need to increase the stack size for the main task. This can be accomplished by adding the following to the <code>sdkconfig.defaults</code> file:</p>
<pre><code class="language-ignore">CONFIG_ESP_MAIN_TASK_STACK_SIZE=7000
</code></pre>
<p>In this example, we are allocating 7kB for the main task's stack.</p>
<h3 id="how-can-i-completely-disable-the-watchdog-timers"><a class="header" href="#how-can-i-completely-disable-the-watchdog-timers">How can I completely disable the watchdog timer(s)?</a></h3>
<p>Add to your <code>sdkconfig.defaults</code> file:</p>
<pre><code class="language-ignore">CONFIG_INT_WDT=n
CONFIG_ESP_TASK_WDT=n
</code></pre>
<p>Recall that you must clean your project before rebuilding when modifying these configuration files.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="assets/mermaid.min.js"></script>
        <script src="assets/mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
